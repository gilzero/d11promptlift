"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSystemRepoInfo = void 0;
const ramda_1 = __importDefault(require("ramda"));
const ajv_1 = __importDefault(require("ajv"));
const ajv_formats_1 = __importDefault(require("ajv-formats"));
const path_1 = require("path");
const fs_1 = require("fs");
const constants_1 = require("../lib/constants");
const log_1 = __importDefault(require("../lib/log"));
const getAvailableSystems_1 = __importDefault(require("../util/system/getAvailableSystems"));
const getGitRepoNameFromUrl_1 = __importDefault(require("../util/getGitRepoNameFromUrl"));
const cloneIntoCache_1 = __importDefault(require("../util/cache/cloneIntoCache"));
const getCachedItemCheckout_1 = __importDefault(require("../util/cache/getCachedItemCheckout"));
const getRepositoryLatestTag_1 = __importDefault(require("../util/getRepositoryLatestTag"));
const installComponentFromCache_1 = __importDefault(require("../util/project/installComponentFromCache"));
const installGeneralAssetsFromCache_1 = __importDefault(require("../util/project/installGeneralAssetsFromCache"));
const getJsonFromCachedFile_1 = __importDefault(require("../util/cache/getJsonFromCachedFile"));
const setEmulsifyConfig_1 = __importDefault(require("../util/project/setEmulsifyConfig"));
const getEmulsifyConfig_1 = __importDefault(require("../util/project/getEmulsifyConfig"));
const findFileInCurrentPath_1 = __importDefault(require("../util/fs/findFileInCurrentPath"));
const executeScript_1 = __importDefault(require("../util/fs/executeScript"));
const system_json_1 = __importDefault(require("../schemas/system.json"));
const variant_json_1 = __importDefault(require("../schemas/variant.json"));
async function getSystemRepoInfo(name, { repository, checkout }) {
    if (repository && checkout) {
        try {
            const repoName = (0, getGitRepoNameFromUrl_1.default)(repository);
            if (repoName) {
                return {
                    name: repoName,
                    repository,
                    checkout,
                };
            }
        }
        catch (error) {
            if (error instanceof Error) {
                return (0, log_1.default)('error', error.message, constants_1.EXIT_ERROR);
            }
            else {
                throw error;
            }
        }
    }
    if (name) {
        const system = (await (0, getAvailableSystems_1.default)()).find(ramda_1.default.propEq('name', name));
        if (system) {
            return {
                name,
                repository: system.repository,
                checkout: system.checkout,
            };
        }
    }
}
exports.getSystemRepoInfo = getSystemRepoInfo;
async function systemInstall(name, options) {
    var _a;
    const projectConfig = await (0, getEmulsifyConfig_1.default)();
    if (!projectConfig) {
        return (0, log_1.default)('error', 'No Emulsify project detected. You must run this command within an existing Emulsify project. For more information about creating Emulsify projects, run "emulsify init --help"', constants_1.EXIT_ERROR);
    }
    if (projectConfig.system) {
        return (0, log_1.default)('error', 'You have already selected a system within this Emulsify project.', constants_1.EXIT_ERROR);
    }
    const repo = await getSystemRepoInfo(name, options);
    if (!repo) {
        return (0, log_1.default)('error', 'Unable to download specified system. You must either specify a valid name of an out-of-the-box system using the --name flag, or specify a valid repository and branch/tag/commit using the --repository and --checkout flags.', constants_1.EXIT_ERROR);
    }
    if (repo.checkout === undefined) {
        repo.checkout = await (0, getRepositoryLatestTag_1.default)(repo.repository);
    }
    await (0, cloneIntoCache_1.default)('systems', [repo.name])({
        repository: repo.repository,
        checkout: repo.checkout,
    });
    const systemConf = await (0, getJsonFromCachedFile_1.default)('systems', [repo.name], repo.checkout, constants_1.EMULSIFY_SYSTEM_CONFIG_FILE);
    if (!systemConf) {
        return (0, log_1.default)('error', `The system you attempted to install (${repo.name}) is invalid, as it does not contain a valid configuration file.`, constants_1.EXIT_ERROR);
    }
    try {
        const ajv = new ajv_1.default();
        (0, ajv_formats_1.default)(ajv, ['uri']);
        ajv.addSchema(variant_json_1.default, 'variant.json');
        const validate = ajv.compile(system_json_1.default);
        if (!validate(systemConf)) {
            throw validate.errors;
        }
    }
    catch (e) {
        console.error('System configuration errors:', e);
        return (0, log_1.default)('error', `The system install failed due to the validation errors reported above. Please fix the the errors in the "${systemConf.name}" configuration and try again.`, constants_1.EXIT_ERROR);
    }
    const variantName = options.variant || projectConfig.project.platform;
    if (!variantName) {
        return (0, log_1.default)('error', 'Unable to determine a variant for the specified system. Please either pass in a valid variant using the --variant flag.', constants_1.EXIT_ERROR);
    }
    const variantConf = (_a = systemConf.variants) === null || _a === void 0 ? void 0 : _a.find(({ platform }) => platform === variantName);
    if (!variantConf) {
        return (0, log_1.default)('error', `Unable to find a variant (${variantName}) within the system (${systemConf.name}). Please check your Emulsify project config and make sure the project.platform value is correct, or select a system with a variant that is compatible with the platform you are using.`, constants_1.EXIT_ERROR);
    }
    try {
        let checkout = repo.checkout;
        if (!checkout) {
            checkout = await (0, getCachedItemCheckout_1.default)('systems', [repo.name]);
        }
        await (0, setEmulsifyConfig_1.default)({
            system: {
                repository: repo.repository,
                checkout,
            },
            variant: {
                platform: variantConf.platform,
                structureImplementations: variantConf.structureImplementations,
            },
        });
    }
    catch (e) {
        return (0, log_1.default)('error', 'Unable to update your Emulsify project configuration.', constants_1.EXIT_ERROR);
    }
    try {
        const componentsList = variantConf.components;
        const requiredComponents = componentsList.filter(({ required }) => required === true);
        for (const component of options.all ? componentsList : requiredComponents) {
            await (0, installComponentFromCache_1.default)(systemConf, variantConf, component.name, true);
        }
        await (0, installGeneralAssetsFromCache_1.default)(systemConf, variantConf);
        const path = (0, findFileInCurrentPath_1.default)(constants_1.EMULSIFY_SYSTEM_CONFIG_FILE);
        const hookPath = path
            ? (0, path_1.join)(path, constants_1.EMULSIFY_PROJECT_HOOK_FOLDER, constants_1.EMULSIFY_PROJECT_HOOK_SYSTEM_INSTALL)
            : undefined;
        if (hookPath && (0, fs_1.existsSync)(hookPath)) {
            await (0, executeScript_1.default)(hookPath);
        }
    }
    catch (e) {
        return (0, log_1.default)('error', `Unable to install system assets and/or required components: ${ramda_1.default.toString(e)}`, constants_1.EXIT_ERROR);
    }
    return (0, log_1.default)('success', `Successfully installed the ${systemConf.name} system using the ${variantConf.platform} variant.`, constants_1.EXIT_SUCCESS);
}
exports.default = systemInstall;
